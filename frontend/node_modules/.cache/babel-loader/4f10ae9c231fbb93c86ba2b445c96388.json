{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\n\nvar url = require('url');\n\nvar util = require('util');\n\nvar AbstractGeocoder = require('./abstractgeocoder');\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options     Options (language, clientId, apiKey, region, excludePartialMatches)\n */\n\n\nvar GoogleGeocoder = function GoogleGeocoder(httpAdapter, options) {\n  this.options = ['language', 'apiKey', 'clientId', 'region', 'excludePartialMatches', 'channel'];\n  GoogleGeocoder.super_.call(this, httpAdapter, options);\n\n  if (this.options.clientId && !this.options.apiKey) {\n    throw new Error('You must specify a apiKey (privateKey)');\n  }\n\n  if (this.options.apiKey && !httpAdapter.supportsHttps()) {\n    throw new Error('You must use https http adapter');\n  }\n};\n\nutil.inherits(GoogleGeocoder, AbstractGeocoder); // Google geocoding API endpoint\n\nGoogleGeocoder.prototype._endpoint = 'https://maps.googleapis.com/maps/api/geocode/json';\n/**\n * Geocode\n * @param <string>   value    Value ton geocode (Address)\n * @param <function> callback Callback method\n */\n\nGoogleGeocoder.prototype._geocode = function (value, callback) {\n  var _this = this;\n\n  var params = this._prepareQueryString();\n\n  if (value.address) {\n    var components = '';\n\n    if (value.country) {\n      components = 'country:' + value.country;\n    }\n\n    if (value.zipcode) {\n      if (components) {\n        components += '|';\n      }\n\n      components += 'postal_code:' + value.zipcode;\n    }\n\n    params.components = this._encodeSpecialChars(components);\n    params.address = this._encodeSpecialChars(value.address);\n  } else if (value.googlePlaceId) {\n    params.place_id = value.googlePlaceId;\n  } else {\n    params.address = this._encodeSpecialChars(value);\n  }\n\n  if (value.language) {\n    params.language = value.language;\n  }\n\n  if (value.region) {\n    params.region = value.region;\n  }\n\n  var excludePartialMatches = params.excludePartialMatches;\n  delete params.excludePartialMatches;\n\n  this._signedRequest(this._endpoint, params);\n\n  this.httpAdapter.get(this._endpoint, params, function (err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      var results = []; // status can be \"OK\", \"ZERO_RESULTS\", \"OVER_QUERY_LIMIT\", \"REQUEST_DENIED\", \"INVALID_REQUEST\", or \"UNKNOWN_ERROR\"\n      // error_message may or may not be present\n\n      if (result.status === 'ZERO_RESULTS') {\n        results.raw = result;\n        return callback(false, results);\n      }\n\n      if (result.status !== 'OK') {\n        return callback(new Error('Status is ' + result.status + '.' + (result.error_message ? ' ' + result.error_message : '')), {\n          raw: result\n        });\n      }\n\n      for (var i = 0; i < result.results.length; i++) {\n        var currentResult = result.results[i];\n\n        if (excludePartialMatches && excludePartialMatches === true && typeof currentResult.partial_match !== 'undefined' && currentResult.partial_match === true) {\n          continue;\n        }\n\n        results.push(_this._formatResult(currentResult));\n      }\n\n      results.raw = result;\n      callback(false, results);\n    }\n  });\n};\n\nGoogleGeocoder.prototype._prepareQueryString = function () {\n  var params = {\n    'sensor': false\n  };\n\n  if (this.options.language) {\n    params.language = this.options.language;\n  }\n\n  if (this.options.region) {\n    params.region = this.options.region;\n  }\n\n  if (this.options.clientId) {\n    params.client = this.options.clientId;\n  } else if (this.options.apiKey) {\n    params.key = this.options.apiKey;\n  }\n\n  if (this.options.channel) {\n    params.channel = this.options.channel;\n  }\n\n  if (this.options.excludePartialMatches && this.options.excludePartialMatches === true) {\n    params.excludePartialMatches = true;\n  }\n\n  return params;\n};\n\nGoogleGeocoder.prototype._signedRequest = function (endpoint, params) {\n  if (this.options.clientId) {\n    var request = url.parse(endpoint);\n    var fullRequestPath = request.path + url.format({\n      query: params\n    });\n    var decodedKey = new Buffer(this.options.apiKey.replace('-', '+').replace('_', '/'), 'base64');\n    var hmac = crypto.createHmac('sha1', decodedKey);\n    hmac.update(fullRequestPath);\n    var signature = hmac.digest('base64');\n    signature = signature.replace(/\\+/g, '-').replace(/\\//g, '_');\n    params.signature = signature;\n  }\n\n  return params;\n};\n\nGoogleGeocoder.prototype._formatResult = function (result) {\n  var googleConfidenceLookup = {\n    ROOFTOP: 1,\n    RANGE_INTERPOLATED: 0.9,\n    GEOMETRIC_CENTER: 0.7,\n    APPROXIMATE: 0.5\n  };\n  var extractedObj = {\n    formattedAddress: result.formatted_address || null,\n    latitude: result.geometry.location.lat,\n    longitude: result.geometry.location.lng,\n    extra: {\n      googlePlaceId: result.place_id || null,\n      confidence: googleConfidenceLookup[result.geometry.location_type] || 0,\n      premise: null,\n      subpremise: null,\n      neighborhood: null,\n      establishment: null\n    },\n    administrativeLevels: {}\n  };\n\n  for (var i = 0; i < result.address_components.length; i++) {\n    for (var x = 0; x < result.address_components[i].types.length; x++) {\n      var addressType = result.address_components[i].types[x];\n\n      switch (addressType) {\n        //Country\n        case 'country':\n          extractedObj.country = result.address_components[i].long_name;\n          extractedObj.countryCode = result.address_components[i].short_name;\n          break;\n        //Administrative Level 1\n\n        case 'administrative_area_level_1':\n          extractedObj.administrativeLevels.level1long = result.address_components[i].long_name;\n          extractedObj.administrativeLevels.level1short = result.address_components[i].short_name;\n          break;\n        //Administrative Level 2\n\n        case 'administrative_area_level_2':\n          extractedObj.administrativeLevels.level2long = result.address_components[i].long_name;\n          extractedObj.administrativeLevels.level2short = result.address_components[i].short_name;\n          break;\n        //Administrative Level 3\n\n        case 'administrative_area_level_3':\n          extractedObj.administrativeLevels.level3long = result.address_components[i].long_name;\n          extractedObj.administrativeLevels.level3short = result.address_components[i].short_name;\n          break;\n        //Administrative Level 4\n\n        case 'administrative_area_level_4':\n          extractedObj.administrativeLevels.level4long = result.address_components[i].long_name;\n          extractedObj.administrativeLevels.level4short = result.address_components[i].short_name;\n          break;\n        //Administrative Level 5\n\n        case 'administrative_area_level_5':\n          extractedObj.administrativeLevels.level5long = result.address_components[i].long_name;\n          extractedObj.administrativeLevels.level5short = result.address_components[i].short_name;\n          break;\n        // City\n\n        case 'locality':\n        case 'postal_town':\n          extractedObj.city = result.address_components[i].long_name;\n          break;\n        // Address\n\n        case 'postal_code':\n          extractedObj.zipcode = result.address_components[i].long_name;\n          break;\n\n        case 'route':\n          extractedObj.streetName = result.address_components[i].long_name;\n          break;\n\n        case 'street_number':\n          extractedObj.streetNumber = result.address_components[i].long_name;\n          break;\n\n        case 'premise':\n          extractedObj.extra.premise = result.address_components[i].long_name;\n          break;\n\n        case 'subpremise':\n          extractedObj.extra.subpremise = result.address_components[i].long_name;\n          break;\n\n        case 'establishment':\n          extractedObj.extra.establishment = result.address_components[i].long_name;\n          break;\n\n        case 'sublocality_level_1':\n        case 'political':\n        case 'sublocality':\n        case 'neighborhood':\n          if (!extractedObj.extra.neighborhood) {\n            extractedObj.extra.neighborhood = result.address_components[i].long_name;\n          }\n\n          break;\n      }\n    }\n  }\n\n  return extractedObj;\n};\n/**\n * Reverse geocoding\n * @param {lat:<number>,lon:<number>}  lat: Latitude, lon: Longitude\n * @param <function> callback Callback method\n */\n\n\nGoogleGeocoder.prototype._reverse = function (query, callback) {\n  var lat = query.lat;\n  var lng = query.lon;\n\n  var _this = this;\n\n  var params = this._prepareQueryString();\n\n  params.latlng = lat + ',' + lng;\n\n  if (query.language) {\n    params.language = query.language;\n  }\n\n  if (query.result_type) {\n    params.result_type = query.result_type;\n  }\n\n  if (query.location_type) {\n    params.location_type = query.location_type;\n  }\n\n  this._signedRequest(this._endpoint, params);\n\n  this.httpAdapter.get(this._endpoint, params, function (err, result) {\n    if (err) {\n      return callback(err);\n    } else {\n      // status can be \"OK\", \"ZERO_RESULTS\", \"OVER_QUERY_LIMIT\", \"REQUEST_DENIED\", \"INVALID_REQUEST\", or \"UNKNOWN_ERROR\"\n      // error_message may or may not be present\n      if (result.status !== 'OK') {\n        return callback(new Error('Status is ' + result.status + '.' + (result.error_message ? ' ' + result.error_message : '')), {\n          raw: result\n        });\n      }\n\n      var results = [];\n\n      if (result.results.length > 0) {\n        results.push(_this._formatResult(result.results[0]));\n      }\n\n      results.raw = result;\n      callback(false, results);\n    }\n  });\n};\n\nGoogleGeocoder.prototype._encodeSpecialChars = function (value) {\n  if (typeof value === 'string') {\n    return value.replace(/\\u001a/g, ' ');\n  }\n\n  return value;\n};\n\nmodule.exports = GoogleGeocoder;","map":null,"metadata":{},"sourceType":"script"}