{"ast":null,"code":"const readline = require('readline');\n\nconst AbstractGeocoder = require('./abstractgeocoder');\n\nconst ValueError = require('./../error/valueerror');\n\nconst OPTIONS = ['apiKey', 'appId', 'appCode', 'language', 'politicalView', 'country', 'state', 'production'];\n/**\n * Constructor\n * @param <object> httpAdapter Http Adapter\n * @param <object> options     Options (appId, appCode, language, politicalView, country, state, production)\n */\n\nclass HereGeocoder extends AbstractGeocoder {\n  constructor(httpAdapter, options) {\n    super(httpAdapter, options);\n    this.options = options;\n    OPTIONS.forEach(option => {\n      if (!options[option] || options[option] == 'undefined') {\n        this.options[option] = null;\n      }\n    }); // appId and appCode are deprecated\n\n    if (!this.options.apiKey && !(this.options.appId && this.options.appCode)) {\n      throw new Error('You must specify apiKey to use Here Geocoder');\n    }\n  }\n  /**\n   * Geocode\n   * @param <string>   value    Value to geocode (Address)\n   * @param <function> callback Callback method\n   */\n\n\n  _geocode(value, callback) {\n    var _this = this;\n\n    var params = this._prepareQueryString();\n\n    if (value.address) {\n      if (value.language) {\n        params.language = value.language;\n      }\n\n      if (value.politicalView) {\n        params.politicalview = value.politicalView;\n      }\n\n      if (value.country) {\n        params.country = value.country;\n\n        if (value.state) {\n          params.state = value.state;\n        } else {\n          delete params.state;\n        }\n      }\n\n      if (value.zipcode) {\n        params.postalcode = value.zipcode;\n      }\n\n      params.searchtext = value.address;\n    } else {\n      params.searchtext = value;\n    }\n\n    this.httpAdapter.get(this._geocodeEndpoint, params, function (err, result) {\n      var results = [];\n      results.raw = result;\n\n      if (err) {\n        return callback(err, results);\n      } else {\n        if (result.type === 'ApplicationError') {\n          return callback(new ValueError(result.Details), results);\n        }\n\n        var view = result.Response.View[0];\n\n        if (!view) {\n          return callback(false, results);\n        } // Format each geocoding result\n\n\n        results = view.Result.map(_this._formatResult);\n        results.raw = result;\n        callback(false, results);\n      }\n    });\n  }\n  /**\n   * Reverse geocoding\n   * @param {lat:<number>,lon:<number>}  lat: Latitude, lon: Longitude\n   * @param <function> callback Callback method\n   */\n\n\n  _reverse(query, callback) {\n    var lat = query.lat;\n    var lng = query.lon;\n\n    var _this = this;\n\n    var params = this._prepareQueryString();\n\n    params.pos = lat + ',' + lng;\n    params.mode = 'trackPosition';\n    this.httpAdapter.get(this._reverseEndpoint, params, function (err, result) {\n      var results = [];\n      results.raw = result;\n\n      if (err) {\n        return callback(err, results);\n      } else {\n        var view = result.Response.View[0];\n\n        if (!view) {\n          return callback(false, results);\n        } // Format each geocoding result\n\n\n        results = view.Result.map(_this._formatResult);\n        results.raw = result;\n        callback(false, results);\n      }\n    });\n  }\n\n  _formatResult(result) {\n    var location = result.Location || {};\n    var address = location.Address || {};\n    var i;\n    var extractedObj = {\n      formattedAddress: address.Label || null,\n      latitude: location.DisplayPosition.Latitude,\n      longitude: location.DisplayPosition.Longitude,\n      country: null,\n      countryCode: address.Country || null,\n      state: address.State || null,\n      county: address.County || null,\n      city: address.City || null,\n      zipcode: address.PostalCode || null,\n      district: address.District || null,\n      streetName: address.Street || null,\n      streetNumber: address.HouseNumber || null,\n      building: address.Building || null,\n      extra: {\n        herePlaceId: location.LocationId || null,\n        confidence: result.Relevance || 0\n      },\n      administrativeLevels: {}\n    };\n\n    for (i = 0; i < address.AdditionalData.length; i++) {\n      var additionalData = address.AdditionalData[i];\n\n      switch (additionalData.key) {\n        //Country 2-digit code\n        case 'Country2':\n          extractedObj.countryCode = additionalData.value;\n          break;\n        //Country name\n\n        case 'CountryName':\n          extractedObj.country = additionalData.value;\n          break;\n        //State name\n\n        case 'StateName':\n          extractedObj.administrativeLevels.level1long = additionalData.value;\n          extractedObj.state = additionalData.value;\n          break;\n        //County name\n\n        case 'CountyName':\n          extractedObj.administrativeLevels.level2long = additionalData.value;\n          extractedObj.county = additionalData.value;\n      }\n    }\n\n    return extractedObj;\n  }\n\n  _prepareQueryString() {\n    var params = {\n      additionaldata: 'Country2,true',\n      gen: 8\n    }; // Deprecated\n\n    if (this.options.appId) {\n      params.app_id = this.options.appId;\n    } // Deprecated\n\n\n    if (this.options.appCode) {\n      params.app_code = this.options.appCode;\n    }\n\n    if (this.options.apiKey) {\n      params.apiKey = this.options.apiKey;\n    }\n\n    if (this.options.language) {\n      params.language = this.options.language;\n    }\n\n    if (this.options.politicalView) {\n      params.politicalview = this.options.politicalView;\n    }\n\n    if (this.options.country) {\n      params.country = this.options.country;\n    }\n\n    if (this.options.state) {\n      params.state = this.options.state;\n    }\n\n    if (this.options.limit) {\n      params.limit = this.options.limit;\n    }\n\n    return params;\n  }\n\n  async _batchGeocode(values, callback) {\n    try {\n      const jobId = await this.__createJob(values);\n      await this.__pollJobStatus(jobId);\n      const rawResults = await this._getJobResults(jobId);\n\n      const results = this.__parseBatchResults(rawResults);\n\n      callback(false, results);\n    } catch (error) {\n      callback(error, null);\n    }\n  }\n\n  async __createJob(values) {\n    const {\n      country\n    } = this.options;\n    const body = `recId|searchText${country ? '|country' : ''}` + '\\n' + values.map((value, ix) => `${ix + 1}|\"${value}\"${country ? `|${country}` : ''}`).join(' \\n') + '\\n';\n    const params = { ...this._prepareQueryString(),\n      action: 'run',\n      outdelim: '|',\n      indelim: '|',\n      header: false,\n      outputcombined: true,\n      outcols: 'latitude,longitude,locationLabel,houseNumber,street,district,city,postalCode,county,state,addressDetailsCountry,country,building,locationId'\n    };\n    const options = {\n      body,\n      headers: {\n        'content-type': 'text/plain',\n        accept: 'application/json'\n      }\n    };\n    const creteJobReq = await new Promise((resolve, reject) => {\n      this.httpAdapter.post(this._batchGeocodeEndpoint, params, options, (err, result) => {\n        if (err) return reject(err);\n        resolve(result);\n      });\n    });\n    const jobRes = await creteJobReq.json();\n\n    if (jobRes.type === 'ApplicationError') {\n      throw new Error(jobRes.Details);\n    }\n\n    return jobRes.Response.MetaInfo.RequestId;\n  }\n\n  async __pollJobStatus(jobId) {\n    let completed = false;\n    let stalledResultsCount = 500;\n    const url = `${this._batchGeocodeEndpoint}/${jobId}`;\n    const params = { ...this._prepareQueryString(),\n      action: 'status'\n    };\n\n    for (; !completed && stalledResultsCount > 0; stalledResultsCount--) {\n      const jobStatus = await new Promise((resolve, reject) => {\n        this.httpAdapter.get(url, params, (err, result) => {\n          if (err) return reject(err);\n          resolve(result);\n        });\n      });\n\n      if (jobStatus.Response.Status === 'completed') {\n        completed = true;\n        break;\n      }\n    }\n\n    if (!completed) {\n      throw new Error('Job timeout');\n    }\n  }\n\n  async _getJobResults(jobId) {\n    // fetch job results\n    const params = { ...this._prepareQueryString(),\n      outputcompressed: false\n    };\n    const jobResult = await new Promise((resolve, reject) => {\n      this.httpAdapter.get(`${this._batchGeocodeEndpoint}/${jobId}/result`, params, (err, result) => {\n        if (err) return reject(err);\n        resolve(result);\n      }, true);\n    });\n    const jobResultLineReadeer = readline.createInterface({\n      input: jobResult.body,\n      crlfDelay: Infinity\n    });\n    const res = [];\n\n    for await (const line of jobResultLineReadeer) {\n      const [\n        /*seqNumber*/\n\n        /*seqLength*/\n      recId,,, latitude, longitude, locationLabel, houseNumber, street, district, city, postalCode, county, state, addressDetailsCountry, country, building, locationId] = line.split('|');\n      const index = Number(recId) - 1; // minus one because our index starts at 0 and theirs at 1\n\n      res[index] = res[index] || {\n        error: null,\n        values: []\n      };\n      res[index].values.push({\n        latitude: Number(latitude),\n        longitude: Number(longitude),\n        houseNumber,\n        street,\n        locationLabel,\n        district,\n        city,\n        postalCode,\n        county,\n        state,\n        addressDetailsCountry,\n        // country name. See formatting\n        country,\n        // contry code. See formatting\n        building,\n        locationId\n      });\n    } // fetch job erros sepparately\n\n\n    const jobErrors = await new Promise((resolve, reject) => {\n      this.httpAdapter.get(`${this._batchGeocodeEndpoint}/${jobId}/errors`, params, (err, result) => {\n        if (err) return reject(err);\n        resolve(result);\n      }, true);\n    });\n    const jobErrorsLineReader = readline.createInterface({\n      input: jobErrors.body,\n      crlfDelay: Infinity\n    });\n\n    for await (const line of jobErrorsLineReader) {\n      const matches = line.match(/Line Number:(?<index>\\d+)\\s+(?<line>.*)/);\n\n      if (matches && matches.groups && matches.index) {\n        const index = Number(matches.groups.index) - 2; // minus one because the first line is the header & one less because our index starts at 0 while theirs at 1\n\n        res[index] = res[index] || {\n          error: null,\n          values: []\n        };\n        res[index].error = matches.groups.line;\n      } else {\n        throw new Error(`Unexpected error line format: \"${line}\"`);\n      }\n    }\n\n    return res;\n  }\n\n  __parseBatchResults(results) {\n    return results.map(result => {\n      const {\n        values,\n        error\n      } = result;\n      return {\n        error,\n        value: values.map(value => {\n          const {\n            latitude,\n            longitude,\n            district,\n            city,\n            county,\n            state,\n            addressDetailsCountry,\n            country,\n            building\n          } = value;\n          return {\n            formattedAddress: value.locationLabel,\n            latitude,\n            longitude,\n            country: addressDetailsCountry,\n            countryCode: country,\n            state,\n            county,\n            city,\n            zipcode: value.postalCode,\n            district,\n            streetName: value.street,\n            streetNumber: value.houseNumber,\n            building,\n            extra: {\n              herePlaceId: value.locationId,\n              confidence: null\n            },\n            provider: 'here'\n          };\n        })\n      };\n    });\n  }\n\n}\n\nObject.defineProperties(HereGeocoder.prototype, {\n  // Here geocoding API endpoint\n  _geocodeEndpoint: {\n    get: function () {\n      return 'https://geocoder.ls.hereapi.com/6.2/geocode.json';\n    }\n  },\n  // Here reverse geocoding API endpoint\n  _reverseEndpoint: {\n    get: function () {\n      return 'https://reverse.geocoder.ls.hereapi.com/6.2/reversegeocode.json';\n    }\n  },\n  // Here batch geocoding API endpoint\n  _batchGeocodeEndpoint: {\n    get: function () {\n      return 'https://batch.geocoder.ls.hereapi.com/6.2/jobs';\n    }\n  }\n});\nmodule.exports = HereGeocoder;","map":null,"metadata":{},"sourceType":"script"}