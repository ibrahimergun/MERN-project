{"ast":null,"code":"'use strict';\n\nconst HttpError = require('../error/httperror.js');\n\nconst nodeFetch = require('node-fetch');\n\nconst BPromise = require('bluebird');\n\nclass FetchAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.fetch = options.fetch || nodeFetch;\n    this.options = { ...options\n    };\n    delete this.options.fetch;\n  }\n\n  supportsHttps() {\n    return true;\n  }\n\n  get(url, params, callback) {\n    let fullResponse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var options = {\n      headers: {\n        'user-agent': 'Mozilla/5.0 (X11; Linux i586; rv:31.0) Gecko/20100101 Firefox/31.0',\n        'accept': 'application/json;q=0.9, */*;q=0.1'\n      }\n    };\n\n    if (this.options) {\n      for (var k in this.options) {\n        var v = this.options[k];\n\n        if (!v) {\n          continue;\n        }\n\n        options[k] = v;\n      }\n    }\n\n    return BPromise.resolve().then(async () => {\n      const queryString = new URLSearchParams(params);\n\n      if (queryString.toString()) {\n        url += `?${queryString.toString()}`;\n      }\n\n      const res = await this.fetch(url, options);\n\n      if (fullResponse) {\n        return res;\n      }\n\n      try {\n        return await res.json();\n      } catch (e) {\n        throw new HttpError(await res.text(), {\n          code: res.statusCode\n        });\n      }\n    }).catch(function (error) {\n      if (error instanceof HttpError) {\n        throw error;\n      }\n\n      const _error = error.cause ? error.cause : error;\n\n      throw new HttpError(_error.message, {\n        code: _error.code\n      });\n    }).asCallback(callback);\n  }\n\n  post(url, params, options, callback) {\n    options.method = 'POST';\n    options.headers = options.headers || {};\n    options.headers['user-agent'] = 'Mozilla/5.0 (X11; Linux i586; rv:31.0) Gecko/20100101 Firefox/31.0';\n\n    if (this.options) {\n      for (var k in this.options) {\n        var v = this.options[k];\n\n        if (!v) {\n          continue;\n        }\n\n        options[k] = v;\n      }\n    }\n\n    return BPromise.resolve().then(async () => {\n      const queryString = new URLSearchParams(params);\n\n      if (queryString.toString()) {\n        url += `?${queryString.toString()}`;\n      }\n\n      return await this.fetch(url, options);\n    }).catch(function (error) {\n      if (error instanceof HttpError) {\n        throw error;\n      }\n\n      const _error = error.cause ? error.cause : error;\n\n      throw new HttpError(_error.message, {\n        code: _error.code\n      });\n    }).asCallback(callback);\n  }\n\n}\n\nmodule.exports = FetchAdapter;","map":null,"metadata":{},"sourceType":"script"}